C51 COMPILER V9.60.7.0   MAIN                                                              09/25/2024 13:12:39 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\ARM_KEIL\Arm\Keil_v5\C51\BIN\C51.EXE source\main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND P
                    -RINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* main.c */
   2          #include "include/18B20.h"
   3          #include "include/ComCDT.h"
   4          #include "include/Relay.h"
   5          #include "include/buzzer.h"
   6          #include "include/pid_controller.h"
   7          #include "include/IKeyEvent.h"
   8          #include "include/serial.h"
   9          #include <intrins.h>
  10          #include <stdio.h>
  11          #include "include/delay.h"
  12          
  13          // å®šä¹‰å¸¸é‡
  14          #define TIMER_0_RELOADS_VALUE 1000    // å®šæ—¶å™¨0é‡è£…å€¼ï¼Œä¸ºæ¯1ms
  15          #define TEMP_CONVERSION_FACTOR 0.0625 // æ¸©åº¦è½¬æ¢ç³»æ•°
  16          #define LOWER_TEMP_LIMIT 28           // æ¸©åº¦ä¸‹é™
  17          #define UPPER_TEMP_LIMIT 30           // æ¸©åº¦ä¸Šé™
  18          #define TARGET_TEMPERATURE 28         // ç›®æ ‡æ¸©åº¦
  19          #define RELAY_HYSTERESIS 2            // æ»åå¸¦å®½ï¼Œå•ä½Â°C
  20          
  21          // ä»»åŠ¡è°ƒåº¦å™¨çš„ä»»åŠ¡ç»“æ„ä½“
  22          typedef struct
  23          {
  24              void (*taskFunction)(void); // ä»»åŠ¡å‡½æ•°æŒ‡é’ˆ
  25              unsigned int period;        // ä»»åŠ¡æ‰§è¡Œçš„å‘¨æœŸ
  26              unsigned int nextExecution; // ä»»åŠ¡ä¸‹æ¬¡æ‰§è¡Œçš„æ—¶é—´
  27          } Task;
  28          
  29          #define MAX_TASKS 5
  30          Task tasks[MAX_TASKS];      // ä»»åŠ¡åˆ—è¡¨
  31          unsigned int taskCount = 0; // ä»»åŠ¡æ•°é‡
  32          
  33          // è°ƒåº¦å™¨å‡½æ•°å£°æ˜
  34          void initializeSystem();
  35          void addTask(void (*taskFunction)(void), unsigned int period);
  36          void scheduler();
  37          
  38          // ä»»åŠ¡å‡½æ•°å£°æ˜
  39          void taskTemperatureUpdate();
  40          void taskControlRelay();
  41          void taskSendTemperature();
  42          void taskControlBuzzer();
  43          
  44          // å®šæ—¶å™¨å‡½æ•°å£°æ˜
  45          void initializeTimer0();
  46          void timer0InterruptHandling(void);
  47          
  48          // å…¨å±€å˜é‡å£°æ˜
  49          unsigned char currentTime = 0;                  // å½“å‰æ—¶é—´ï¼Œä»¥1msä¸ºå•ä½
  50          float temperature = 0.0;                        // å½“å‰æ¸©åº¦
  51          unsigned char integerPart = 0, decimalPart = 0; // æ¸©åº¦çš„æ•´æ•°éƒ¨åˆ†å’Œå°æ•°éƒ¨åˆ†
  52          unsigned char setpoint = TARGET_TEMPERATURE;    // ç›®æ ‡æ¸©åº¦
  53          unsigned char integral = 0;                     // PIDç§¯åˆ†é¡¹
  54          unsigned char previous_error = 0;               // ä¸Šä¸€ä¸ªè¯¯å·®
C51 COMPILER V9.60.7.0   MAIN                                                              09/25/2024 13:12:39 PAGE 2   

  55          bit displayTemperatureOrTime = 1;               // æ§åˆ¶æ¸©åº¦/æ—¶é—´æ˜¾ç¤ºåˆ‡æ¢
  56          
  57          void main(void)
  58          {
  59   1          // åˆå§‹åŒ–DS18B20æ¸©åº¦ä¼ æ„Ÿå™¨æ¨¡å—
  60   1          Init_DS18B20();
  61   1      
  62   1          // åˆå§‹åŒ–ä¸²å£
  63   1          initSerial(); // åˆå§‹åŒ–ä¸²å£å‡½æ•°
  64   1      
  65   1          // åˆå§‹åŒ–è°ƒåº¦å™¨å’Œä»»åŠ¡
  66   1          initializeSystem();
  67   1      
  68   1          // æ— é™å¾ªç¯
  69   1          while (1)
  70   1          {
  71   2              // è°ƒç”¨è°ƒåº¦å™¨å¤„ç†ä»»åŠ¡
  72   2              scheduler();
  73   2              checkButtons();
  74   2          }
  75   1      }
  76          
  77          // åˆå§‹åŒ–ç³»ç»Ÿ
  78          void initializeSystem()
  79          {
  80   1          // åˆå§‹åŒ–å®šæ—¶å™¨0
  81   1          initializeTimer0();
  82   1      
  83   1          // æ·»åŠ ä»»åŠ¡åˆ°è°ƒåº¦å™¨
  84   1          addTask(taskTemperatureUpdate, 10); // æ¯10æ¯«ç§’æ›´æ–°ä¸€æ¬¡æ¸©åº¦
  85   1          addTask(taskControlRelay, 1000);    // æ¯1ç§’æ§åˆ¶ä¸€æ¬¡ç»§ç”µå™¨
  86   1          addTask(taskControlBuzzer, 2);      // æ¯1ç§’å‘é€ä¸€æ¬¡æ¸©åº¦ä¿¡æ¯
  87   1          // addTask(taskSendTemperature, 500);  // æ¯0.5ç§’å‘é€ä¸€æ¬¡æ¸©åº¦ä¿¡æ¯
  88   1      }
  89          
  90          // åˆå§‹åŒ–å®šæ—¶å™¨0
  91          void initializeTimer0()
  92          {
  93   1          // è®¾ç½®å®šæ—¶å™¨0ä¸ºæ¨¡å¼1ï¼ˆ16ä½å®šæ—¶å™¨/è®¡æ•°å™¨æ¨¡å¼ï¼‰
  94   1          TMOD &= 0xF0; // æ¸…é™¤å®šæ—¶å™¨0çš„æ¨¡å¼ä½
  95   1          TMOD |= 0x01; // è®¾ç½®å®šæ—¶å™¨0ä¸ºæ¨¡å¼1ï¼ˆ16ä½å®šæ—¶å™¨ï¼‰
  96   1      
  97   1          // åˆå§‹åŒ–å®šæ—¶å™¨0çš„åˆå€¼
  98   1          TH0 = (65536 - TIMER_0_RELOADS_VALUE) / 256;
  99   1          TL0 = (65536 - TIMER_0_RELOADS_VALUE) % 256;
 100   1      
 101   1          // å¼€å¯å…¨å±€ä¸­æ–­å’Œå®šæ—¶å™¨0ä¸­æ–­
 102   1          EA = 1;
 103   1          ET0 = 1;
 104   1      
 105   1          // å¯åŠ¨å®šæ—¶å™¨0
 106   1          TR0 = 1;
 107   1      }
 108          
 109          // å®šæ—¶å™¨0ä¸­æ–­å¤„ç†å‡½æ•°
 110          void timer0InterruptHandling(void) interrupt 1
 111          {
 112   1          // é‡æ–°è£…è½½å®šæ—¶å™¨0çš„åˆå€¼
 113   1          TH0 = (65536 - TIMER_0_RELOADS_VALUE) / 256;
 114   1          TL0 = (65536 - TIMER_0_RELOADS_VALUE) % 256;
 115   1      
 116   1          // æ›´æ–°å½“å‰æ—¶é—´ï¼Œæ¯æ¬¡ä¸­æ–­è¡¨ç¤º1ms
C51 COMPILER V9.60.7.0   MAIN                                                              09/25/2024 13:12:39 PAGE 3   

 117   1          currentTime++;
 118   1      }
 119          
 120          // æ·»åŠ ä»»åŠ¡
 121          void addTask(void (*taskFunction)(void), unsigned int period)
 122          {
 123   1          if (taskCount < MAX_TASKS)
 124   1          {
 125   2              tasks[taskCount].taskFunction = taskFunction;
 126   2              tasks[taskCount].period = period;
 127   2              tasks[taskCount].nextExecution = currentTime + period;
 128   2              taskCount++;
 129   2          }
 130   1      }
 131          
 132          // æ¸©åº¦æ›´æ–°ä»»åŠ¡
 133          void taskTemperatureUpdate()
 134          {
 135   1          // è¯»å–æ¸©åº¦å¹¶è½¬æ¢ä¸ºå®é™…æ¸©åº¦å€¼
 136   1          temperature = ReadTemperature() * TEMP_CONVERSION_FACTOR;
 137   1      
 138   1          // è®¡ç®—æ¸©åº¦çš„æ•´æ•°éƒ¨åˆ†å’Œå°æ•°éƒ¨åˆ†
 139   1          integerPart = (int)temperature;
 140   1          decimalPart = (int)((temperature - integerPart) * 100);
 141   1      
 142   1          // æ ¹æ®æ˜¾ç¤ºæ¨¡å¼ï¼Œæ˜¾ç¤ºæ¸©åº¦æˆ–æ—¶é—´
 143   1          if (displayTemperatureOrTime)
 144   1          {
 145   2              displayTemperature(integerPart, decimalPart);
 146   2          }
 147   1          else
 148   1          {
 149   2              displayTime(60); // ç¤ºä¾‹ï¼šæ˜¾ç¤º60åˆ†é’Ÿ
 150   2          }
 151   1      }
 152          
 153          // ç»§ç”µå™¨æ§åˆ¶ä»»åŠ¡
 154          void taskControlRelay()
 155          {
 156   1          // æ§åˆ¶é€»è¾‘ï¼šä½äºä¸‹é™æ¸©åº¦-æ»åå¸¦å®½æ‰“å¼€ç»§ç”µå™¨ï¼Œè¶…è¿‡ä¸Šé™æ¸©åº¦+æ»åå¸¦å®½å…³é
             -—­ç»§ç”µå™¨
 157   1          if (temperature < (LOWER_TEMP_LIMIT - RELAY_HYSTERESIS))
 158   1          {
 159   2              relayOpened();
 160   2              DelayUs2x(25);
 161   2          }
 162   1          else if (temperature > (UPPER_TEMP_LIMIT + RELAY_HYSTERESIS))
 163   1          {
 164   2              relayClosed();
 165   2              DelayUs2x(25);
 166   2          }
 167   1          else
 168   1          {
 169   2              // å½“æ¸©åº¦åœ¨ä¸Šä¸‹é™ä¹‹é—´æ—¶ä½¿ç”¨PIDæ§åˆ¶
 170   2              pIDControl();
 171   2              DelayUs2x(25);
 172   2          }
 173   1      }
 174          
 175          void taskControlBuzzer()
 176          {
 177   1          // æ ¹æ®æ¸©åº¦åˆ¤æ–­èœ‚é¸£å™¨çŠ¶æ€
C51 COMPILER V9.60.7.0   MAIN                                                              09/25/2024 13:12:39 PAGE 4   

 178   1          if (temperature < LOWER_TEMP_LIMIT)
 179   1          {
 180   2              buzzerOn(); // æ¸©åº¦ä½äºä¸‹é™æ—¶ï¼Œæ‰“å¼€èœ‚é¸£å™¨
 181   2              DelayUs2x(25);
 182   2          }
 183   1          else if (temperature > UPPER_TEMP_LIMIT)
 184   1          {
 185   2              buzzerOff(); // æ¸©åº¦é«˜äºä¸Šé™æ—¶ï¼Œå…³é—­èœ‚é¸£å™¨
 186   2              DelayUs2x(25);
 187   2          }
 188   1          else
 189   1          {
 190   2              // åœ¨æ¸©åº¦æ­£å¸¸èŒƒå›´å†…ï¼Œå¯ä»¥é€‰æ‹©å…³é—­èœ‚é¸£å™¨æˆ–ä¿æŒå½“å‰çŠ¶æ€
 191   2              buzzerOff(); // å¯é€‰ï¼šåœ¨æ­£å¸¸èŒƒå›´å†…å…³é—­èœ‚é¸£å™¨
 192   2              DelayUs2x(25);
 193   2          }
 194   1      }
 195          
 196          // è°ƒåº¦å™¨ï¼šæ£€æŸ¥å¹¶æ‰§è¡Œæ¯ä¸ªä»»åŠ¡
 197          void scheduler()
 198          {
 199   1          unsigned char i;
 200   1          for (i = 0; i < taskCount; i++)
 201   1          {
 202   2              if (currentTime >= tasks[i].nextExecution)
 203   2              {
 204   3                  tasks[i].taskFunction();                                // æ‰§è¡Œä»»åŠ¡
 205   3                  tasks[i].nextExecution = currentTime + tasks[i].period; // æ›´æ–°ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´
 206   3              }
 207   2          }
 208   1      }
 209          
 210          // å‘é€æ¸©åº¦ä»»åŠ¡
 211          void taskSendTemperature()
 212          {
 213   1          unsigned char buffer[10];
 214   1          sprintf(buffer, "Temperature: %d.%d C", integerPart, decimalPart);
 215   1          sendSerial(buffer); // å‘é€æ¸©åº¦ä¿¡æ¯
 216   1          DelayUs2x(25);
 217   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    492    ----
   CONSTANT SIZE    =     21    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     47      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
